var documenterSearchIndex = {"docs":
[{"location":"docs/gvf.html#GVFs","page":"GVF","title":"GVFs","text":"","category":"section"},{"location":"docs/gvf.html","page":"GVF","title":"GVF","text":"CurrentModule = MinimalRLCore","category":"page"},{"location":"docs/gvf.html","page":"GVF","title":"GVF","text":"Modules = [MinimalRLCore]\nPages   = [\"gvf.jl\", \"gvf/cumulant.jl\", \"gvf/discount.jl\", \"gvf/policy.jl\"]","category":"page"},{"location":"docs/environments.html#Environment","page":"Environments","title":"Environment","text":"","category":"section"},{"location":"docs/environments.html","page":"Environments","title":"Environments","text":"CurrentModule = MinimalRLCore","category":"page"},{"location":"docs/environments.html","page":"Environments","title":"Environments","text":"Modules = [MinimalRLCore]\nPages   = [\"environment.jl\"]","category":"page"},{"location":"docs/environments.html#MinimalRLCore.AbstractEnvironment","page":"Environments","title":"MinimalRLCore.AbstractEnvironment","text":"Represents an abstract environment for reinforcement learning agents. Has several functions that need to be implemented to work.  All interfaces expect an abstract environment!\n\n\n\n\n\n","category":"type"},{"location":"docs/environments.html#MinimalRLCore.environment_step!-Tuple{AbstractEnvironment,Any,Vararg{Any,N} where N}","page":"Environments","title":"MinimalRLCore.environment_step!","text":"environment_step!(env::AbstractEnvironment, action, args...)\n\nUpdate the state of the environment based on the underlying dynamics and the action. This is not used directly, but through the step function.\n\nYou can implement with or without a personally defined RNG. If you choose to not implement with a personally maintained RNG remember this is not a thread safe function.\n\n\n\n\n\n","category":"method"},{"location":"docs/environments.html#MinimalRLCore.get_reward-Tuple{AbstractEnvironment}","page":"Environments","title":"MinimalRLCore.get_reward","text":"get_reward(env::AbstractEnvironment)\n\nRetrieve reward for the current state of the environment.\n\n\n\n\n\n","category":"method"},{"location":"docs/environments.html#MinimalRLCore.get_state-Tuple{AbstractEnvironment}","page":"Environments","title":"MinimalRLCore.get_state","text":"get_state(env::AbstractEnvironment)\n\nRetrieve the current state of the environment\n\n\n\n\n\n","category":"method"},{"location":"docs/environments.html#MinimalRLCore.is_terminal-Tuple{AbstractEnvironment}","page":"Environments","title":"MinimalRLCore.is_terminal","text":"is_terminal(env::AbstractEnvironment)\n\nCheck if the environment is in a terminal state\n\n\n\n\n\n","category":"method"},{"location":"docs/environments.html#MinimalRLCore.reset!-Tuple{AbstractEnvironment,Vararg{Any,N} where N}","page":"Environments","title":"MinimalRLCore.reset!","text":"reset!(env::AbstractEnvironment, args...)\n\nReset the environment to initial conditions based on the random number generator.\n\nYou can implement with or without a personally defined RNG. If you choose to not implement with a personally maintained RNG remember this is not a thread safe function.\n\n\n\n\n\n","category":"method"},{"location":"docs/environments.html#MinimalRLCore.start!-Tuple{AbstractEnvironment,Vararg{Any,N} where N}","page":"Environments","title":"MinimalRLCore.start!","text":"start!(env::AbstractEnvironment, args...)\n\nFunction to start the passed environment env. There are three variants. Two which start the environment from a random start state (as implemented with reset!) and another which starts the environment from a provided start state. These three variants call the reset! functions of the same call signiture.\n\nReturns the starting state of the environment.\n\n\n\n\n\n","category":"method"},{"location":"docs/environments.html#MinimalRLCore.step!-Tuple{AbstractEnvironment,Any,Vararg{Any,N} where N}","page":"Environments","title":"MinimalRLCore.step!","text":"step!(env::AbstractEnvironment, action, args...)\n\nUpdate the state of the passed environment env based on the underlying dynamics and the action.\n\n\n\n\n\n","category":"method"},{"location":"docs/learning.html#Learning","page":"Learning","title":"Learning","text":"","category":"section"},{"location":"docs/agents.html#Agents","page":"Agents","title":"Agents","text":"","category":"section"},{"location":"docs/agents.html","page":"Agents","title":"Agents","text":"CurrentModule = MinimalRLCore","category":"page"},{"location":"docs/agents.html","page":"Agents","title":"Agents","text":"Modules = [MinimalRLCore]\nPages   = [\"agent.jl\"]","category":"page"},{"location":"docs/agents.html#MinimalRLCore.end!-Tuple{AbstractAgent,Any,Any,Vararg{Any,N} where N}","page":"Agents","title":"MinimalRLCore.end!","text":"end!(agent::AbstractAgent, evn_s_tp1, r, args...)\n\nFunction called when the environment is terminated. Default calls step!(agent, env_s_tp1, r, true, args...)\n\n\n\n\n\n","category":"method"},{"location":"docs/agents.html#MinimalRLCore.start!-Tuple{AbstractAgent,Any,Vararg{Any,N} where N}","page":"Agents","title":"MinimalRLCore.start!","text":"start!(agent::AbstractAgent, env_s_tp1, args...)\n\nFunction for starting the agent for a new episode. \n\nreturns an action to get passed to the environment\n\n\n\n\n\n","category":"method"},{"location":"docs/agents.html#MinimalRLCore.step!-Tuple{AbstractAgent,Any,Any,Any,Vararg{Any,N} where N}","page":"Agents","title":"MinimalRLCore.step!","text":"step!(agent::AbstractAgent, env_s_tp1, r, terminal, args...)\n\nFunction to take a step with an agent.\n\nReturns an action to get passed to the environment.\n\n\n\n\n\n","category":"method"},{"location":"manual/environment.html#Using-the-Environment-API","page":"Environments","title":"Using the Environment API","text":"","category":"section"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"This document serves as a guide in how to implement and use the AbstractEnvironment API. You can find full documentation in the documentation section. Some of these details are out of date but will be updated after the API stabilizes.","category":"page"},{"location":"manual/environment.html#Implementing-a-new-environment","page":"Environments","title":"Implementing a new environment","text":"","category":"section"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"We are going to implement the Mountain Car in this document to get used to how we take advantage of the API, and some of the functionality we get by implementing the full API!","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"I often create a module which contains several environment constants (which are consistent across all versions of this environment). You can also accomplish this by creating a few functions for the type to inline these values, and many other ways. You want to make sure to declare these global variables constant to get nice compiler optimizations for global scope variables. There are also other ways of handling this such as: creating inline functions return the values you care about, others...","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"module MountainCarConst\nconst vel_limit = (-0.07, 0.07)\nconst pos_limit = (-1.2, 0.5)\nconst pos_initial_range = (-0.6, 0.4)\n\nconst Reverse=1\nconst Neutral=2\nconst Accelerate=3\nend","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"We create the initial MountainCar struct which is a subtype of AbstractEnvironment. There are several functions we must implement if we want to take advantage of the MinimalRLCore API.","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"MinimalRLCore.reset!\nMinimalRLCore.environment_step!","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"mutable struct MountainCar <: MinimalRLCore.AbstractEnvironment\n    pos::Float64\n    vel::Float64\n    actions::AbstractSet\n    normalized::Bool\n    function MountainCar(pos=0.0, vel=0.0, normalized::Bool=false)\n        mcc = MountainCarConst\n        @boundscheck (pos >= mcc.pos_limit[1] && pos <= mcc.pos_limit[2])\n        @boundscheck (vel >= mcc.vel_limit[1] && vel <= mcc.vel_limit[2])\n        new(pos, vel, Set([mcc.Reverse, mcc.Neutral, mcc.Accelerate]), normalized)\n    end\nend","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"MinimalRLCore.get_actions(env::MountainCar) = env.actions\nvalid_action(env::MountainCar, action) = action in env.actions","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"function MinimalRLCore.reset!(env::MountainCar, rng::AbstractRNG; kwargs...)\n    env.pos = (rand(rng)*(MountainCarConst.pos_initial_range[2]\n                          - MountainCarConst.pos_initial_range[1])\n               + MountainCarConst.pos_initial_range[1])\n    env.vel = 0.0\nend\n\nfunction MinimalRLCore.reset!(env::MountainCar,\n                        start_state::T;\n                        kwargs...) where {T<:AbstractArray}\n    if env.normalized\n        env.pos = start_state[1]\n        env.vel = start_state[2]\n    else\n        pos_limit = MountainCarConst.pos_limit\n        vel_limit = MountainCarConst.vel_limit\n        env.pos = (start_state[1]*(pos_limit[2] - pos_limit[1])) + pos_limit[1]\n        env.vel = (start_state[2]*(vel_limit[2] - vel_limit[1])) + vel_limit[1]\n    end\nend","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"function MinimalRLCore.environment_step!(env::MountainCar,\n                                   action,\n                                   rng; kwargs...)\n    \n    @boundscheck valid_action(env, action)\n    env.vel =\n        clamp(env.vel + (action - 2)*0.001 - 0.0025*cos(3*env.pos),\n              MountainCarConst.vel_limit...)\n    env.pos = clamp(env.pos + env.vel,\n                    MountainCarConst.pos_limit...)\nend","category":"page"},{"location":"manual/environment.html","page":"Environments","title":"Environments","text":"function MinimalRLCore.get_reward(env::MountainCar) # -> determines if the agent_state is terminal\n    if env.pos >= MountainCarConst.pos_limit[2]\n        return 0\n    end\n    return -1\nend\n\n\nfunction MinimalRLCore.is_terminal(env::MountainCar) # -> determines if the agent_state is terminal\n    return env.pos >= MountainCarConst.pos_limit[2]\nend\n\n\nfunction MinimalRLCore.get_state(env::MountainCar)\n    if env.normalized\n        return get_normalized_state(env)\n    else\n        return [env.pos, env.vel]\n    end\nend\n\n\nfunction get_normalized_state(env::MountainCar)\n    pos_limit = MountainCarConst.pos_limit\n    vel_limit = MountainCarConst.vel_limit\n    return [(env.pos - pos_limit[1])/(pos_limit[2] - pos_limit[1]),\n            (env.vel - vel_limit[1])/(vel_limit[2] - vel_limit[1])]\nend\n","category":"page"},{"location":"index.html#MinimalRLCore.jl-Documentation-WIP","page":"Home","title":"MinimalRLCore.jl Documentation - WIP","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"This documentation is still a work in progress. We should have a finalized version for the initial release on the Julia package system.","category":"page"},{"location":"docs/feature_creators.html#Feature-Constructors","page":"Feature Constructor","title":"Feature Constructors","text":"","category":"section"},{"location":"docs/feature_creators.html","page":"Feature Constructor","title":"Feature Constructor","text":"CurrentModule = MinimalRLCore","category":"page"},{"location":"docs/feature_creators.html","page":"Feature Constructor","title":"Feature Constructor","text":"Modules = [MinimalRLCore]\nPages   = [\"feature_constructors.jl\"]","category":"page"},{"location":"docs/feature_creators.html#MinimalRLCore.AbstractFeatureConstructor","page":"Feature Constructor","title":"MinimalRLCore.AbstractFeatureConstructor","text":"AbstractFeatureCreator\n\nAn abstract feature creator, for feature transformation from the states.\n\n\n\n\n\n","category":"type"},{"location":"docs/feature_creators.html#MinimalRLCore.create_features","page":"Feature Constructor","title":"MinimalRLCore.create_features","text":"create_features\n\nActually create the features\n\n\n\n\n\n","category":"function"},{"location":"docs/feature_creators.html#MinimalRLCore.feature_size-Tuple{AbstractFeatureConstructor}","page":"Feature Constructor","title":"MinimalRLCore.feature_size","text":"feature_size(fc::AbstractFeatureCreator)\n\nDepricated! Use Base.size instead. Get size of feature vector the features assume exists.\n\n\n\n\n\n","category":"method"}]
}
